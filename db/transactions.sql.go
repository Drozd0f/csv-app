// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: transactions.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

type CreateTransactionsParams struct {
	TransactionID      int32     `json:"transaction_id"`
	RequestID          int32     `json:"request_id"`
	TerminalID         int32     `json:"terminal_id"`
	PartnerObjectID    int32     `json:"partner_object_id"`
	AmountTotal        int32     `json:"amount_total"`
	AmountOriginal     int32     `json:"amount_original"`
	CommissionPs       int32     `json:"commission_ps"`
	CommissionClient   int32     `json:"commission_client"`
	CommissionProvider int32     `json:"commission_provider"`
	DateInput          time.Time `json:"date_input"`
	DatePost           time.Time `json:"date_post"`
	Status             string    `json:"status"`
	PaymentType        string    `json:"payment_type"`
	PaymentNumber      string    `json:"payment_number"`
	ServiceID          int32     `json:"service_id"`
	Service            string    `json:"service"`
	PayeeID            int32     `json:"payee_id"`
	PayeeName          string    `json:"payee_name"`
	PayeeBankMfo       int32     `json:"payee_bank_mfo"`
	PayeeBankAccount   string    `json:"payee_bank_account"`
	PaymentNarrative   string    `json:"payment_narrative"`
}

const getTransactions = `-- name: GetTransactions :many
SELECT transaction_id, request_id, terminal_id, partner_object_id, amount_total, amount_original, commission_ps, commission_client, commission_provider, date_input, date_post, status, payment_type, payment_number, service_id, service, payee_id, payee_name, payee_bank_mfo, payee_bank_account, payment_narrative
FROM transactions
ORDER BY transaction_id LIMIT $2 OFFSET $1
`

type GetTransactionsParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) GetTransactions(ctx context.Context, arg GetTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.RequestID,
			&i.TerminalID,
			&i.PartnerObjectID,
			&i.AmountTotal,
			&i.AmountOriginal,
			&i.CommissionPs,
			&i.CommissionClient,
			&i.CommissionProvider,
			&i.DateInput,
			&i.DatePost,
			&i.Status,
			&i.PaymentType,
			&i.PaymentNumber,
			&i.ServiceID,
			&i.Service,
			&i.PayeeID,
			&i.PayeeName,
			&i.PayeeBankMfo,
			&i.PayeeBankAccount,
			&i.PaymentNarrative,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sliceTransactions = `-- name: SliceTransactions :many
SELECT transaction_id, request_id, terminal_id, partner_object_id, amount_total, amount_original, commission_ps, commission_client, commission_provider, date_input, date_post, status, payment_type, payment_number, service_id, service, payee_id, payee_name, payee_bank_mfo, payee_bank_account, payment_narrative
FROM transactions
WHERE ($1::INTEGER = 0 OR transaction_id = $1)
AND ($2::TEXT = 'default' OR status = $2)
AND ($3::TEXT = 'default' OR payment_type = $3)
AND (($4::TIMESTAMP = '0001-01-01' AND $5::TIMESTAMP = '0001-01-01') OR date_post BETWEEN $4 AND $5)
AND ($1::TEXT = '' OR payment_narrative SIMILAR TO '%' || $6 || '%')
AND (cardinality($7::INTEGER[]) = 0 OR terminal_id = ANY($7))
`

type SliceTransactionsParams struct {
	TransactionID    int32          `json:"transaction_id"`
	Status           string         `json:"status"`
	PaymentType      string         `json:"payment_type"`
	DatePostFrom     time.Time      `json:"date_post_from"`
	DatePostTo       time.Time      `json:"date_post_to"`
	PaymentNarrative sql.NullString `json:"payment_narrative"`
	TerminalID       []int32        `json:"terminal_id"`
}

func (q *Queries) SliceTransactions(ctx context.Context, arg SliceTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, sliceTransactions,
		arg.TransactionID,
		arg.Status,
		arg.PaymentType,
		arg.DatePostFrom,
		arg.DatePostTo,
		arg.PaymentNarrative,
		arg.TerminalID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.RequestID,
			&i.TerminalID,
			&i.PartnerObjectID,
			&i.AmountTotal,
			&i.AmountOriginal,
			&i.CommissionPs,
			&i.CommissionClient,
			&i.CommissionProvider,
			&i.DateInput,
			&i.DatePost,
			&i.Status,
			&i.PaymentType,
			&i.PaymentNumber,
			&i.ServiceID,
			&i.Service,
			&i.PayeeID,
			&i.PayeeName,
			&i.PayeeBankMfo,
			&i.PayeeBankAccount,
			&i.PaymentNarrative,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
